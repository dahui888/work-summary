### 一道百度面试算法题
>下午的时候收到一个猎头发送的题目，后来网络搜索下发现原来是百度曾经的一道面试题。

**题目一**
>数组a中只有一个数出现一次，其他数都出现了2次，找出这个数字。

分析：题目也算是常见的面试题，在Java中我们可以借助集合之类的辅助来完成这类的数字统计，最后得出结果，但是根据面试出题人的思路，更多的考察是&、^、|运算符的巧用。

- & 按位与，按位与运算符"&"是双目运算符。其功能是参与运算的两数各对应的二进位相与。只有对应的两个二进位均为1时，结果位才为1 ，否则为0。
-  | 按位或运算 按位或运算符“|”是双目运算符。其功能是参与运算的两数各对应的二进位相或。只要对应的二个二进位有一个为1时，结果位就为1。
- ^  按位异或运算 按位异或运算符“^”是双目运算符。其功能是参与运算的两数各对应的二进位相异或，当两对应的二进位相异时，结果为1。

**重要结论：**
- 0异或任何数＝任何数
- 任何数异或自己＝把自己置0

所以在这个题目中，我们使用^运算符，最后就是0^目标数=目标数。
```java
public static int find1From2(int []a){
    if(a == null || a.length == 0)return -1;
    int len,number = 0;
    len = a.length;
    for(int i=0;i<len;i++){
        number ^= a[i];
    }
    return number;
}
```

**题目二**
>一个整型数组里除了两个数字之外，其他的数字都出现了两次。请写程序找出这两个只出现一次的数字。

分析：
基于问题一中的分析，我们同样也是采取同样的思路。

用位运算实现，如果将所有所有数字相异或，则最后的结果肯定是那两个只出现一次的数字异或的结果，所以根据异或的结果1所在的最低位，把数字分成两半，每一半里都还有只出现一次的数据和成对出现的数据。这样继续对每一半相异或则可以分别求出两个只出现一次的数字。
```java
public static void find2From2(int [] array,int num1[] , int num2[]){
    if(array == null || array.length ==0){
        num1[0] = num2[0] = 0;
        return;
    }
    int len = array.length;
    /**
     * 标志不同这两个数的不同位
     */
    int index;
    int sum = 0;
    for(int i=0; i <len; i++){
        sum ^= array[i];
    }

    //针对32位进行&运算，找出出现不同位的位置,即低位1的位置。
    for(index=0;index<32;index++){
        if((sum & (1<<index)) != 0)break;
    }

    for(int i=0;i<len;i++){
        if((array[i] & (1 << index)) != 0){//相同的数肯定进入同一判断，最后肯定都是抵消掉。
            num1[0] ^= array[i];
        }else{
            num2[0] ^= array[i];
        }
    }
}
```

**题目三**
>数组a中只有一个数出现一次，其他数字都出现了3次，找出这个数字。

分析：
利用两个相同的数异或结果为0来计算的，但这个题目中其他数字是出现了3次，因此肯定不可以再使用异或了。我们换一个角度来看，如果数组中没有x，那么数组中所有的数字都出现了3次，在二进制上，每位上1的个数肯定也能被3整除。

推广一下，所有其他数字出现N（N>=2）次，而一个数字出现1次都可以用这种解法来推导出这个出现1次的数字。
```java
 public static int find1From3(int[] a){
     int[] bits = new int[32];
     int len = a.length;
     for(int i = 0; i < len; i++){
         for(int j = 0; j < 32; j++){
             bits[j] = bits[j] + ( (a[i]>>>j) & 1);
         }
     }
     int res = 0;
     for(int i = 0; i < 32; i++){
         if(bits[i] % 3 !=0){
             res = res | (1 << i);
         }
     }
     return res;
 }
```

最近也在看数据结构与算法类的知识，很重要，找一份好工作更重要。